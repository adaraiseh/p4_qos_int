diff --git a/targets/simple_switch/simple_switch.cpp b/targets/simple_switch/simple_switch.cpp
index dcb597f..7d05ed2 100644
--- a/targets/simple_switch/simple_switch.cpp
+++ b/targets/simple_switch/simple_switch.cpp
@@ -644,6 +644,9 @@ void
 SimpleSwitch::egress_thread(size_t worker_id) {
   PHV *phv;
 
+  std::unordered_map<port_t, uint64_t> last_transmitted_bytes;
+  std::unordered_map<port_t, uint64_t> last_update_time_us;
+
   while (1) {
     std::unique_ptr<Packet> packet;
     size_t port;
@@ -676,6 +679,41 @@ SimpleSwitch::egress_thread(size_t worker_id) {
 
     phv->get_field("standard_metadata.egress_port").set(port);
 
+    // AMJ CODE TX Utilization Calculation
+    // Get the current time and port stats
+    uint64_t current_time_us = get_time_elapsed_us(); // Current time in microseconds
+    auto port_stats = DevMgr::get_port_stats(port);   // Access port stats
+    uint64_t transmitted_bytes = port_stats.out_octets;
+
+    // Calculate bytes transmitted and elapsed time since last update
+    uint64_t last_bytes = last_transmitted_bytes[port];
+    uint64_t last_time_us = last_update_time_us[port];
+    uint64_t bytes_diff = transmitted_bytes - last_bytes;
+    uint64_t time_diff_us = current_time_us - last_time_us;
+
+    // Log the debug information
+    BMLOG_DEBUG("Port {}: transmitted_bytes={}, last_bytes={}, bytes_diff={}",
+                port, transmitted_bytes, last_bytes, bytes_diff);
+    BMLOG_DEBUG("Port {}: current_time_us={}, last_time_us={}, time_diff_us={}",
+                port, current_time_us, last_time_us, time_diff_us);
+
+    if (time_diff_us > 0) {
+        const uint64_t max_bandwidth_bps = 10 * 1e6; // 10 Mbps
+        float tx_utilization = (8.0 * bytes_diff * 1e6) / (time_diff_us * max_bandwidth_bps);
+        tx_utilization = std::min(1.0f, tx_utilization); // Ensure it doesn't exceed 100%
+
+        // Log the calculated utilization
+        BMLOG_DEBUG("Port {}: TX utilization={} (scaled: {})",
+                    port, tx_utilization, static_cast<int>(tx_utilization * 1e6));
+
+        // Attach TX utilization to metadata (if INT is enabled)
+        phv->get_field("queueing_metadata.tx_utilization").set(
+            static_cast<int>(tx_utilization * 1e6)); // Scale to micro-units
+    }
+
+    // Update the stored values
+    last_transmitted_bytes[port] = transmitted_bytes;
+    last_update_time_us[port] = current_time_us;
     Field &f_egress_spec = phv->get_field("standard_metadata.egress_spec");
     // When egress_spec == drop_port the packet will be dropped, thus
     // here we initialize egress_spec to a value different from drop_port.
